<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Chatbot (Single File)</title>
<style>
  :root {
    --bg: #f7f8fb;
    --container: #ffffff;
    --user: #cfe9ff;
    --bot: #eef2f6;
    --muted: #6c7480;
    --accent: #3478f6;
    --radius: 12px;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  body { background: var(--bg); margin:0; padding:20px; display:flex; justify-content:center; }
  .panel { width:100%; max-width:820px; background:var(--container); border-radius:16px; box-shadow:0 6px 24px rgba(30,40,60,0.06); padding:18px; }
  h1 { margin:0 0 10px 0; font-size:20px; }
  #chat { height:440px; overflow:auto; border-radius:12px; padding:16px; background:linear-gradient(180deg,#fbfdff, #f1f6fb); border:1px solid #e6eef8; }
  .msg { display:inline-block; padding:10px 12px; margin:8px 0; border-radius:12px; max-width:78%; line-height:1.25; }
  .user { background:var(--user); margin-left:auto; text-align:right; border-bottom-right-radius:4px; }
  .bot  { background:var(--bot); margin-right:auto; text-align:left; border-bottom-left-radius:4px; }
  .meta { font-size:11px; color:var(--muted); margin-top:6px; }
  #controls { display:flex; gap:8px; margin-top:12px; }
  #input { flex:1; min-height:44px; padding:10px 12px; border-radius:10px; border:1px solid #d9e6ff; font-size:15px; }
  button { background:var(--accent); color:white; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; }
  button.secondary { background:#eef2f6; color:#2b3a4a; border:1px solid #dbe7f7; }
  .controls-row { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:12px; }
  .small { font-size:13px; color:var(--muted); }
  .typing { font-style:italic; color:var(--muted); padding:6px 8px; }
  .actions { display:flex; gap:8px; }
  @media (max-width:520px){ #chat{height:340px} }
</style>
</head>
<body>
  <div class="panel" role="main">
    <h1>Mini Chatbot — Single File</h1>
    <div id="chat" aria-live="polite" aria-atomic="false"></div>

    <div id="controls">
      <div style="flex:1;">
        <div contenteditable="true" id="input" role="textbox" aria-label="Type your message" placeholder="Type a message (try: remember this: buy milk)"></div>
      </div>
      <div style="display:flex;flex-direction:column;gap:8px;">
        <button id="send">Send</button>
        <button id="clear" class="secondary" title="Clear visible chat">Clear</button>
      </div>
    </div>

    <div class="controls-row">
      <div class="small">Session stored locally. Messages persist across refresh.</div>
      <div class="actions">
        <button id="export" class="secondary" title="Download chat as text">Export</button>
        <button id="reset" class="secondary" title="Forget remembered notes">Reset Memory</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Utilities ----------
  const $ = id => document.getElementById(id);
  const chatEl = $('chat');
  const inputEl = $('input');
  const sendBtn = $('send');
  const clearBtn = $('clear');
  const exportBtn = $('export');
  const resetBtn = $('reset');

  const STORAGE_KEY = 'mini_chat_history_v1';
  const MEM_KEY = 'mini_chat_notes_v1';

  function nowISO() { return new Date().toISOString(); }
  function formatTime(iso) {
    const d = new Date(iso);
    return d.toLocaleString();
  }

  function saveHistory(history) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
  }
  function loadHistory() {
    try {
      return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
    } catch(e) { return []; }
  }
  function saveNotes(notes) { localStorage.setItem(MEM_KEY, JSON.stringify(notes)); }
  function loadNotes() { try { return JSON.parse(localStorage.getItem(MEM_KEY) || '[]'); } catch(e){ return []; } }

  // ---------- Rendering ----------
  function appendBubble(text, who='bot', ts=null, meta=null) {
    const wrap = document.createElement('div');
    const bubble = document.createElement('div');
    bubble.className = 'msg ' + (who==='user' ? 'user' : 'bot');
    bubble.textContent = text;
    wrap.appendChild(bubble);
    if (meta || ts) {
      const m = document.createElement('div');
      m.className = 'meta';
      m.textContent = (meta ? meta + ' · ' : '') + (ts ? formatTime(ts) : '');
      wrap.appendChild(m);
    }
    chatEl.appendChild(wrap);
    chatEl.scrollTop = chatEl.scrollHeight;
  }

  function showTyping() {
    const t = document.createElement('div');
    t.className = 'typing meta';
    t.id = '__typing';
    t.textContent = 'Bot is typing...';
    chatEl.appendChild(t);
    chatEl.scrollTop = chatEl.scrollHeight;
  }
  function hideTyping() {
    const t = document.getElementById('__typing');
    if (t) t.remove();
  }

  // ---------- Bot logic (rule-based with tiny memory) ----------
  // memory: array of notes (strings)
  let memory = loadNotes();

  // small intent/responses
  function ruleReply(userText, lastHistory) {
    const text = (userText || '').trim();
    const tl = text.toLowerCase();

    // greetings
    if (/\b(cdp upload report|cdp pathway|cdp report pathway|cdp report|cdp)\b/.test(tl)) {
      return "Community Development, summer Internships and OJT Report upload via UMS link-- Academics-->Project/Dissertation-->Upload Research Project/Internship Certificate--->Internship Report with Certificate option.";
    }
    if (/\b(st report last date|st last date|st upload date|st uploading last date|st report last date)\b/.test(tl)) {
      return "Last day of Uploading the report is 20th September 2025";
    }
    if (/\b(R grade|r grade|r grade registration|r registration|reappear r grade|R PROJECT course|r)\b/.test(tl)) {
      return "R grade registrations open twice every year. First in month of Feburary and then in the month of August every year. R grade registration fee is 1000/- without any late fee and 3000/- with a late fee of 2000/-. UMS announcement and student UMS notification are sent to each student for R grade registrations. There is only 1 R grade chance in Capstone/Dissertation courses where as 3 chances in case of Summer Internship/Community Development Project/On the Job Training.";
    }
    // help
    if (tl.includes('help')) {
      return "I understand simple commands:\n• remember this: <note>\n• what did i tell you\n• reset memory\nYou can also say hello.";
    }
    // remember command
    const m = tl.match(/^remember this:\s*(.+)/i);
    if (m) {
      const note = m[1].trim();
      memory.push({note, time: nowISO()});
      saveNotes(memory);
      return `Okay — I'll remember: "${note}"`;
    }
    // show memory
    if (tl.includes('what did i tell') || tl.includes('what did i say') || tl === 'memory' || tl.includes('remembered')) {
      if (memory.length === 0) return "You haven't asked me to remember anything yet.";
      return "You asked me to remember:\n" + memory.map((n,i)=> `${i+1}. ${n.note} (${formatTime(n.time)})`).join('\n');
    }
    // small talk
    if (tl.includes('how are you')) return "I'm a small script — feeling speedy! ⚡";
    if (tl.includes('time') && tl.includes('now')) return `It's ${formatTime(nowISO())}.`;
    // fallback: echo + context-aware (if lastHistory exists)
    if (lastHistory) {
      return `Earlier you said: "${lastHistory.user}" — now: "${userText}"`;
    }
    return `I heard: "${userText}"`;
  }

  // ---------- Persistence ----------
  function pushHistory(entry) {
    const hist = loadHistory();
    hist.push(entry);
    saveHistory(hist);
  }

  function renderFullHistory() {
    chatEl.innerHTML = '';
    const hist = loadHistory();
    hist.forEach(h => {
      if (h.type === 'user') appendBubble(h.text, 'user', h.time);
      else appendBubble(h.text, 'bot', h.time);
    });
  }

  // ---------- Actions ----------
  async function sendMessage() {
    const text = inputEl.textContent.trim();
    if (!text) return;
    const ts = nowISO();
    appendBubble(text, 'user', ts);
    pushHistory({type:'user', text, time:ts});
    inputEl.textContent = '';
    // typing indicator
    showTyping();

    // simulate processing delay
    await new Promise(r => setTimeout(r, 450 + Math.random()*400));

    hideTyping();
    // compute reply using last user from history
    const hist = loadHistory();
    // find last user message before this (excluding the one we just added)
    let lastUser = null;
    for (let i=hist.length-1;i>=0;i--) if (hist[i].type==='user' && hist[i].text!==text){ lastUser = hist[i]; break; }

    const reply = ruleReply(text, lastUser);
    const rts = nowISO();
    appendBubble(reply, 'bot', rts);
    pushHistory({type:'bot', text:reply, time:rts});
  }

  // Export chat as .txt
  function exportChat() {
    const hist = loadHistory();
    if (!hist.length) { alert('No chat to export'); return; }
    const lines = hist.map(h => `[${formatTime(h.time)}] ${h.type.toUpperCase()}: ${h.text}`);
    const blob = new Blob([lines.join('\\n')], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'chat_export.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // ---------- Event wiring ----------
  sendBtn.addEventListener('click', sendMessage);
  clearBtn.addEventListener('click', ()=> { chatEl.innerHTML=''; });
  exportBtn.addEventListener('click', exportChat);
  resetBtn.addEventListener('click', ()=> {
    if (!confirm('This will erase remembered notes (memory). Continue?')) return;
    memory = [];
    saveNotes(memory);
    alert('Memory cleared.');
  });

  // hit Enter to send (Shift+Enter for newline)
  inputEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  // init render
  renderFullHistory();

  // placeholder text behavior for contenteditable
  function ensurePlaceholder() {
    if (!inputEl.textContent.trim()) { inputEl.setAttribute('data-empty', 'true'); inputEl.style.color='#8894a6'; inputEl.textContent = ''; }
    inputEl.style.minHeight = '44px';
  }
  ensurePlaceholder();

  // make sure contenteditable is focusable and accessible
  inputEl.setAttribute('role','textbox');
  inputEl.setAttribute('aria-multiline','true');

})();
</script>
<!-- Add this button somewhere in your UI (e.g., next to Export chat): -->
<button id="export-searches" class="secondary" title="Download search logs (CSV)">Export Searches</button>

<script>
/* --- keep existing UI elements and functions unchanged above ... --- */

(function(){
  // existing variables (chat, qInput, askBtn, clearBtn, resultsDiv) should exist
  const chat = document.getElementById('chat');
  const qInput = document.getElementById('q');
  const askBtn = document.getElementById('ask');
  const clearBtn = document.getElementById('clear');
  const resultsDiv = document.getElementById('results');

  // session id persisted locally
  let sessionId = localStorage.getItem('mini_chat_session_id');
  if (!sessionId) {
    sessionId = 'sid_' + Math.random().toString(36).slice(2,10);
    localStorage.setItem('mini_chat_session_id', sessionId);
  }

  function appendMsg(text, cls='bot') {
    const d=document.createElement('div');
    d.className='msg '+cls;
    d.textContent = text;
    chat.appendChild(d);
    chat.scrollTop = chat.scrollHeight;
  }

  async function doSearch(q) {
    appendMsg(q, 'user');
    appendMsg('Searching spreadsheet…', 'bot');
    try {
      // include session_id in the query so server can log it
      const resp = await fetch('/search?q=' + encodeURIComponent(q) + '&session_id=' + encodeURIComponent(sessionId));
      const data = await resp.json();

      // remove the 'Searching...' bot message
      const botMsgs = Array.from(document.querySelectorAll('.msg.bot'));
      if (botMsgs.length) botMsgs[botMsgs.length-1].remove();

      if (!data.count) {
        appendMsg('No results found.', 'bot');
        resultsDiv.innerHTML = '';
        return;
      }
      appendMsg(`Found ${data.count} matching rows. Showing up to ${data.results.length}.`, 'bot');

      const rows = data.results;
      const keys = Object.keys(rows[0]).slice(0, 12);
      let html = '<table><thead><tr>' + keys.map(k=>'<th>'+k+'</th>').join('') + '</tr></thead><tbody>';
      rows.forEach((r, idx)=>{
        html += '<tr data-idx="'+idx+'">';
        keys.forEach(k=> html += '<td>' + String(r[k]).substring(0,120) + '</td>');
        html += '</tr>';
      });
      html += '</tbody></table>';
      resultsDiv.innerHTML = html;

      document.querySelectorAll('tr[data-idx]').forEach((tr,i)=>{
        tr.addEventListener('click', ()=>{
          const r = rows[i];
          const detail = Object.keys(r).map(k=> `${k}: ${r[k]}`).join('\n');
          alert(detail);
        });
      });
    } catch (e) {
      appendMsg('Error querying server: ' + e.message, 'bot');
    }
  }

  askBtn.addEventListener('click', ()=> {
    const q = qInput.value.trim();
    if (!q) { alert('Type a search term'); return; }
    doSearch(q);
  });
  qInput.addEventListener('keydown', (e)=> { if (e.key==='Enter') askBtn.click(); });
  clearBtn.addEventListener('click', ()=> { chat.innerHTML=''; resultsDiv.innerHTML=''; });

  // Export searches button
  const exportSearchesBtn = document.getElementById('export-searches');
  if (exportSearchesBtn) {
    exportSearchesBtn.addEventListener('click', async ()=> {
      if (!confirm('Download search logs (CSV)? This file may contain IP addresses and User-Agent strings.')) return;
      try {
        const resp = await fetch('/export_searches');
        if (!resp.ok) {
          const json = await resp.json().catch(()=>null);
          alert('Export failed: ' + (json && json.error ? json.error : resp.statusText));
          return;
        }
        const blob = await resp.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'search_logs.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        alert('Failed to download logs: ' + err.message);
      }
    });
  }

})();
</script>

</body>
</html>
